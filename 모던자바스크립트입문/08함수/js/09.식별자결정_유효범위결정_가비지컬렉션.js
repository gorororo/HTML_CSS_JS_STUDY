// 논리적인 연결고리(선형목록), 스커프체인, 외부 렉시컬 환경 체인, 유효 범위 체인

let a = "A"; // 전역변수
function f() {
    let b = "B"; // 함수 f 의 지역변수 이자 function g 의 렉시컬 컴포넌트 안의 변수
    function g(){
        let c = "C"; // g 의 지역변수 이자 선언적 환경 레코드 
        console.log('a+b+c :>> ', a+b+c);
    }
    g();
}
f();

// 가비지 컬렉션 
// 프로그램에서 객체를 생성하면 메모리 공간이 동적으로 확보됩니다.
// 사용하지 않는 객체의 메모리 영역은 가비지 컬렉터가 자동으로 해제합니다.
// 이 메커니즘을 가르켜 garbage collection 라고 합니다 이때 
// 사용하지 않은 객체란 다른 객체의 프로퍼티 와 변수가 참조 하지 않는 객체를 말합니다.

var p = {x:1,y:2};
console.log('p :>> ', p);
p = null; // 여기서 가비지 컬렉터 발동 메모리에서 해제한다.

// 예전엔 참조 카운터(객체 개수가 0이 될었을 때 메모리에서 해제)) 방식 이방식은 순환 참조가 발생했을 때 메모리 누수가 발생한다는 단점

// var p = {p:{x:0,y:0}, q :{x:0,y:1}};
// p.next = q;
// q.next = p; 
// 대충 위 두값에 null을 채워도 서로 순환 참조하므로 메모리 해제가 안된다는뜻 예제에 오류가 좀 있는듯?

// 최근의 주요 웹 브라우저는 마크앤 스윕(Mark-and-Sweep)알고리즘을 사용한다
// 전역 객체가 참조 할수 없는 객체를 검색하고 해당하는 객체가 있다면 필요 없는 객체라고 판단하여 메모리에서 해제하는 방식
